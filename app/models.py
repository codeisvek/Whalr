from app import db
from hashlib import md5
from .scraper import *

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nickname = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)

    """
    In general the is_authenticated method should just return True 
    unless the object represents a user that should 
    not be allowed to authenticate for some reason.
    """

    def is_authenticated(self):
        return True

    """
    The is_active method should return True for 
    users unless they are inactive, 
    for example because they have been banned.
    """

    def is_active(self):
        return True

    """
    The is_anonymous method should return True 
    only for fake users that are not supposed 
    to log in to the system.
    """

    def is_anonymous(self):
        return False

    """
    Finally, the get_id method should return a 
    unique identifier for the user, in unicode 
    format. We use the unique id generated by the 
    database layer for this. 
    (Due to the differences in unicode handling 
    between Python 2 and 3 we have to provide two 
    alternative versions of this method.)
    """

    def get_id(self):
        try:
            return unicode(self.id)  # python 2
        except NameError:
            return str(self.id)  # python 3

    def avatar(self, size):
        return 'http://www.gravatar.com/avatar/%s?d=mm&s=%d' % (md5(self.email.encode('utf-8')).hexdigest(), size)

    def __repr__(self):
        return '<User %r>' % (self.nickname)

class Food(db.Model):
    __tablename__ = "food"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Text)
    calories = db.Column(db.Integer())
    frequency = db.Column(db.Integer())
    timeOfDay = db.Column(db.Integer())
    lastServed = db.Column(db.Date)
    location = db.Column(db.Text)
    def __init__(self, name, calories, lastServed, location, timeOfDay):
        self.name = name
        self.calories = calories
        self.frequency = 1
        if lastServed is None:
            lastServed = date.min()
        self.lastServed = lastServed
        if location == 0:
            location = "Crossroads"
        elif location == 1:
            location = "Cafe 3"
        elif location == 2:
            location = "Foothill"
        elif location == 3:
            location = "Clark Kerr"
        else:
            location = "Nowhere"
        self.location = location
        if timeOfDay is None:
            timeOfDay = "Never"
        self.timeOfDay = timeOfDay
        print(self.name)
        print(self.calories)
        print(self.location) 
    def __repr__(self):
        return '<name %r>' % self.name
    db.create_all()
    def add_food(base, link):
        soup = make_soup(base + link)
        date = serve_day(soup)
        foods = find_food(soup)
        n = []
        t = []
        l = []
        for food in foods:
            n.append(food[0])
            t.append(food[1])
            l.append(food[2])
        food_links = find_food_links(soup)
        for x in range(0, len(n)):
            if Food.query.filter_by(name=n[x]).first() != None:
                Name = Food.query.filter_by(name=n[x]).first()

                Food.update_food(Name, date, l[x], t[x])

                update_food(Name, date, l[x], t[x])

                db.session.commit()
            else:
                food_url = re.sub(r'web/\*/', '', food_links[x])
                new_soup = make_soup(base + food_url)
                food_info = find_food_info(new_soup)
                if food_info['calories'] != 0:
                    new_food = Food(n[x], food_info['calories'], date, l[x], t[x])
                    db.session.add(new_food)
                    db.session.commit()
    #Create database from archive
    def create_archive():
        date_links = get_food()
        for day in date_links:
            Food.add_food(base_url, day)
    def get_menu_today():
        dining_root = 'http://services.housing.berkeley.edu/FoodPro/dining/static/'
        dining_menu = 'todaysentrees.asp'
        Food.add_food(dining_root, dining_menu)
    def update_food(food, date, location, time):
        if date > food.lastServed:
            food.frequency += 1
        food.lastServed = date
        food.location = location
        food.timeOfDay = time